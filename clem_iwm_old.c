/**
 * @file clem_iwm.c
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2021-05-12
 *
 * @copyright Copyright (c) 2021
 *
 */

#include "clem_device.h"
#include "clem_drive.h"
#include "clem_debug.h"
#include "clem_mmio_defs.h"
#include "clem_util.h"

#include <string.h>

/*
    IWM emulation

    Interface:
        iwm_reset
        iwm_glu_sync
        iwm_write_switch
        iwm_read_switch

    Feeds/Lines:
        io_flags + phase - Disk Port
        Data Bus
        IO Switches
        Clock

    Notes from the 1982 Spec
    http://www.brutaldeluxe.fr/documentation/iwm/apple2_IWM_Spec_Rev19_1982.pdf

    - Reads and writes to drive (GCR encoded 8-bit 'nibbles')
    - Effectively a state machine controlled by Q6+Q7 (two internal flags)
    - Supplementary features controlled by the IO DISKREG and IWM mode
      registers
    - States
        - READ and WRITE DATA states
        - READ STATUS
        - READ HANDSHAKE
        - WRITE MODE


*/


void clem_iwm_reset(struct ClemensDeviceIWM* iwm) {
    memset(iwm, 0, sizeof(*iwm));

    /* Jim Sather's 'example' initial state - evaluate if it's necessary */
    iwm->lss_seq = 0x02;
}

void clem_iwm_insert_disk(
   struct ClemensDeviceIWM* iwm,
   enum ClemensDriveType drive_type
) {
    // set disk
    // reset drive state

}

void clem_iwm_eject_disk(
    struct ClemensDeviceIWM* iwm,
    enum ClemensDriveType drive_type
) {
    // clear disk after timeout
    // after timeout, reset drive state
}


void _clem_iwm_lss(struct ClemensDeviceIWM* iwm) {
    /* indexing rom instructions generated by Jim Slater,
       seq | read/write | shift/load | QA | pulse
       note that senses like write protect may be acquired using the status
       register - which may always be used in even legacy code?
       if not, then we need to determine if:
        5.25 and synchronous, use the LSS only for A2 compatability
        5.25 and asynchronous, use the LSS and override when needed to read
            from status/handshake registers
    */
    unsigned adr = (unsigned)(iwm->lss_seq) << 4 |
                   (iwm->q7_switch ? 0x08 : 00) |
                   (iwm->q6_switch ? 0x04 : 00) |
                   ((iwm->latch & 0x80) ? 0x02 : 00) |
                   ((iwm->io_flags & CLEM_IWM_FLAG_READ_DATA) ? 0x01 : 00);
    unsigned cmd = s_lss_525_rom[adr];

    if (cmd & 0x08) {
        switch (cmd & 0xf) {
            case 0x08:              /* NOP */
            case 0x0C:
                break;
            case 0x09:              /* SL0 */
                iwm->latch <<= 1;
                break;
            case 0x0A:              /* SR, WRPROTECT -> HI */
            case 0x0E:
                iwm->latch >>= 1;
                if (iwm->io_flags & CLEM_IWM_FLAG_WRPROTECT_SENSE) {
                    iwm->latch |= 0x80;
                }
                break;
            case 0x0B:              /* LD from data to latch */
            case 0x0F:
                iwm->latch = iwm->data;
                break;
            case 0x0D:              /* SL1 append 1 bit */
                iwm->latch <<= 1;
                iwm->latch |= 0x01;
                break;
        }
    } else {
        /* CLR */
        iwm->latch = 0;
    }

    iwm->lss_seq = (cmd & 0xf0) >> 4;
}

void clem_iwm_glu_sync(
    struct ClemensDeviceIWM* iwm,
    struct ClemensDriveBay* drives,
    struct ClemensClock* clock
) {
    int delta_ns = _clem_calc_ns_step_from_clocks(
        clock->ts - iwm->last_clocks_ts, clock->ref_step);
    int ns_budget = 0;
    if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON) {
        /* handle the 1 second drive motor timer */
        if (iwm->ns_drive_hold > 0) {
            iwm->ns_drive_hold = clem_util_timer_decrement(
                iwm->ns_drive_hold, delta_ns);
            if (iwm->ns_drive_hold == 0 || iwm->timer_1sec_disabled) {
                CLEM_LOG("clem_iwm: turning drive off in sync");
                iwm->io_flags &= ~CLEM_IWM_FLAG_DRIVE_ON;
            }
        }
    }
    if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON) {
        ns_budget = delta_ns;
        while (ns_budget >= CLEM_IWM_LSS_CYCLE_NS) {
            if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_35) {
                if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_1) {
                    _clem_disk_update_state_35(&drives->slot5[0],
                                               &iwm->io_flags,
                                               iwm->out_phase,
                                               CLEM_IWM_LSS_CYCLE_NS);
                }
                if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_2) {
                    _clem_disk_update_state_35(&drives->slot5[1],
                                               &iwm->io_flags,
                                               iwm->out_phase,
                                               CLEM_IWM_LSS_CYCLE_NS);
                }
            } else {
                if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_1) {
                    _clem_disk_update_state_525(&drives->slot6[0],
                                                &iwm->io_flags,
                                                iwm->out_phase,
                                                CLEM_IWM_LSS_CYCLE_NS);
                }
                if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_2) {
                    _clem_disk_update_state_525(&drives->slot6[1],
                                                &iwm->io_flags,
                                                iwm->out_phase,
                                                CLEM_IWM_LSS_CYCLE_NS);
                }
            }
            _clem_iwm_lss(iwm);
            ns_budget -= CLEM_IWM_LSS_CYCLE_NS;
        }
    }
    iwm->last_clocks_ts = clock->ts - _clem_calc_clocks_step_from_ns(
        ns_budget, clock->ref_step);
}

/*
    Reading IWM addresses only returns data based on the state of Q6, Q7, and
    only if reading from even io addresses.  The few exceptions are addresses
    outside of the C0E0-EF range.

    Disk II treats Q6,Q7 as simple Read or Write/Write Protect state switches.
    The IIgs controller in addition also provides accesses the special IWM
    registers mentioned.
*/

void _clem_iwm_io_switch(
   struct ClemensDeviceIWM* iwm,
   struct ClemensDriveBay* drives,
   struct ClemensClock* clock,
   uint8_t ioreg,
   uint8_t op
) {
    bool old_q6 = iwm->q6_switch, old_q7 = iwm->q7_switch;

    switch (ioreg) {
        case CLEM_MMIO_REG_IWM_DRIVE_DISABLE:
            if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON) {
                if (iwm->timer_1sec_disabled) {
                    CLEM_LOG("clem_iwm: turning drive off now");
                    iwm->io_flags &= ~CLEM_IWM_FLAG_DRIVE_ON;
                } else if (iwm->ns_drive_hold == 0) {
                    CLEM_LOG("clem_iwm: turning drive off in 1 second");
                    iwm->ns_drive_hold = CLEM_1SEC_NS;
                }
            }
            break;
        case CLEM_MMIO_REG_IWM_DRIVE_ENABLE:
            if (!(iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON)) {
                CLEM_LOG("clem_iwm: turning drive on");
            }
            iwm->io_flags |= CLEM_IWM_FLAG_DRIVE_ON;
            iwm->ns_drive_hold = 0;
            break;
        case CLEM_MMIO_REG_IWM_DRIVE_0:
            if (!(iwm->io_flags & CLEM_IWM_FLAG_DRIVE_1)) {
                CLEM_LOG("clem_iwm: setting drive 1");
            }
            iwm->io_flags |= CLEM_IWM_FLAG_DRIVE_1;
            iwm->io_flags &= ~CLEM_IWM_FLAG_DRIVE_2;
            break;
        case CLEM_MMIO_REG_IWM_DRIVE_1:
            if (!(iwm->io_flags & CLEM_IWM_FLAG_DRIVE_2)) {
                CLEM_LOG("clem_iwm: setting drive 2");
            }
            iwm->io_flags |= CLEM_IWM_FLAG_DRIVE_2;
            iwm->io_flags &= ~CLEM_IWM_FLAG_DRIVE_1;
            break;
        case CLEM_MMIO_REG_IWM_Q6_LO:
            iwm->q6_switch = false;
            break;
        case CLEM_MMIO_REG_IWM_Q6_HI:
            iwm->q6_switch = true;
            break;
        case CLEM_MMIO_REG_IWM_Q7_LO:
            iwm->q7_switch = false;
            break;
        case CLEM_MMIO_REG_IWM_Q7_HI:
            iwm->q7_switch = true;
            break;
        default:
            if (ioreg >= CLEM_MMIO_REG_IWM_PHASE0_LO &&
                ioreg <= CLEM_MMIO_REG_IWM_PHASE3_HI
            ) {
                if (ioreg & 1) {
                    iwm->out_phase |= (
                        1 << ((ioreg - CLEM_MMIO_REG_IWM_PHASE0_HI) >> 1));
                } else {
                    iwm->out_phase &= ~(
                        1 << ((ioreg - CLEM_MMIO_REG_IWM_PHASE0_LO) >> 1));
                }
            }
            break;
    }

    if (old_q6 != iwm->q6_switch || old_q7 != iwm->q7_switch) {
        unsigned last_state = (old_q7 ? 0x02 : 0x00) |
                              (old_q6 ? 0x01 : 0x00);
        unsigned this_state = (iwm->q7_switch ? 0x02 : 0x00) |
                              (iwm->q6_switch ? 0x01 : 0x00);
        CLEM_LOG("clem_iwm: state from %02X to %02X", last_state, this_state);
    }

    if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON) {
        /* emulate the drive just enough to catch up with the current
           cycles spent executing the instruction that invokes this IO.
           we also adjust our lag timer negatively, so that our later
           call to glu_sync() will only IWM frames for the remaining time
           budget this emulation frame
        */
       /* TODO: use clocks instead of cycles here... and in the IWM struct */
       clem_iwm_glu_sync(iwm, drives, clock);
    }
}

static void _clem_iwm_write_mode(struct ClemensDeviceIWM* iwm, uint8_t value) {
    if (value & 0x10) {
        iwm->clock_8mhz = true;
        CLEM_WARN("clem_iwm: 8mhz mode requested");
    } else {
        iwm->clock_8mhz = false;
    }
    if (value & 0x08) {
        iwm->fast_mode = true;
    } else {
        iwm->fast_mode = false;
    }
    if (value & 0x04) {
        iwm->timer_1sec_disabled = true;
    } else {
        iwm->timer_1sec_disabled = false;
    }
    if (value & 0x02) {
        iwm->async_write_mode = true;
        /* TODO: set up counters for handshake register */
    } else {
        iwm->async_write_mode = false;
    }
    /* TODO: hold latch for a set time using the ns_latch_hold when reading and
             latch MSB == 1*/
    if (value & 0x01) {
        iwm->latch_mode = true;
    } else {
        iwm->latch_mode = false;
    }
    CLEM_LOG("clem_iwm: write mode %02X", value);
}

void clem_iwm_write_switch(
    struct ClemensDeviceIWM* iwm,
    struct ClemensDriveBay* drives,
    struct ClemensClock* clock,
    uint8_t ioreg,
    uint8_t value
) {
    unsigned old_io_flags = iwm->io_flags;
    switch (ioreg) {
        case CLEM_MMIO_REG_DISK_INTERFACE:
            if (value & 0x80) {
                iwm->io_flags |= CLEM_IWM_FLAG_HEAD_SEL;
            } else {
                iwm->io_flags &= ~CLEM_IWM_FLAG_HEAD_SEL;
            }
            if (value & 0x40) {
                iwm->io_flags |= CLEM_IWM_FLAG_DRIVE_35;
                if (!(old_io_flags & CLEM_IWM_FLAG_DRIVE_35)) {
                    CLEM_LOG("clem_iwm: setting 3.5 drive mode");
                }
            } else {
                iwm->io_flags &= ~CLEM_IWM_FLAG_DRIVE_35;
                if (old_io_flags & CLEM_IWM_FLAG_DRIVE_35) {
                    CLEM_LOG("clem_iwm: setting 5.25 drive mode");
                }
            }
            if (value & 0x3f) {
                CLEM_WARN("clem_iwm: setting unexpected diskreg flags %02X", value);
            }
            break;
        default:
            iwm->data = value;
            _clem_iwm_io_switch(iwm, drives, clock, ioreg, CLEM_IO_WRITE);
            if (ioreg & 1) {
                if (iwm->q7_switch && iwm->q6_switch) {
                    if (!(iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON)) {
                        _clem_iwm_write_mode(iwm, value);
                    }
                }
            }
            break;
    }
}

static uint8_t _clem_iwm_read_status(struct ClemensDeviceIWM* iwm) {
    uint8_t result = 0;

    if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ON &&
        iwm->io_flags & CLEM_IWM_FLAG_DRIVE_ANY
    ) {
        result |= 0x20;
    }

    if (iwm->io_flags & CLEM_IWM_FLAG_WRPROTECT_SENSE) {
        result |= 0x80;
    }
    /* mode flags reflected here */
    /* TODO: a bunch of IIgs specfic modes */
    if (iwm->clock_8mhz) {
        result |= 0x10;
    }
    if (iwm->fast_mode) {
        result |= 0x08;
    }
    if (iwm->timer_1sec_disabled) {
        result |= 0x04;
    }
    if (iwm->async_write_mode) {
        result |= 0x02;
    }
    if (iwm->latch_mode) {
        result |= 0x01;
    }

    return result;
}

uint8_t clem_iwm_read_switch(
    struct ClemensDeviceIWM* iwm,
    struct ClemensDriveBay* drives,
    struct ClemensClock* clock,
    uint8_t ioreg,
    uint8_t flags
) {
    uint8_t result = 0x00;

    switch (ioreg) {
        case CLEM_MMIO_REG_DISK_INTERFACE:
            if (iwm->io_flags & CLEM_IWM_FLAG_HEAD_SEL) {
                result |= 0x80;
            } else {
                result &= ~0x80;
            }
            if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_35) {
                result |= 0x40;
            } else {
                result &= 0x40;
            }
            break;
        default:
            if (!(flags & CLEM_MMIO_READ_NO_OP)) {
                _clem_iwm_io_switch(iwm, drives, clock, ioreg, CLEM_IO_READ);
            }
            if (!(ioreg & 1)) {
                /* read data latch */
                if (iwm->q6_switch) {
                    if (!iwm->q7_switch) {
                        result = _clem_iwm_read_status(iwm);
                    }
                } else {
                    if (iwm->q7_switch) {
                        if (iwm->io_flags & CLEM_IWM_FLAG_DRIVE_35) {
                            /* read handshake */
                        } else {
                            /* use latch value generated by lss */
                            result = 0;
                        }
                    } else {
                        result = iwm->latch;
                    }
                }
            }
            break;
    }

    return result;
}
